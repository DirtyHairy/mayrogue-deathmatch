/* global describe, it, expect, beforeEach, spyOn */

require('../bootstrap').bootstrap(__dirname + '/..');

var _ = require('underscore');

var requirejs = require('requirejs'),
    Util = requirejs('util');

describe('The class manager', function() {
    var fooFlag = false,
        Ancestor = Util.Class.define({
            foo: function() {
                fooFlag = true;
            }
        }),
        ancestor = new Ancestor();
    
    beforeEach(function() {
        fooFlag = false;
    });
    
    it('allows descendants to inherit their parents properties', function() {
        var Descendant = Util.extend(Ancestor, {
                bar: function() {
                }
            }),
            descendant = new Descendant();
        
        expect(ancestor.foo).toBeDefined();
        expect(ancestor.bar).not.toBeDefined();
        expect(descendant.foo).toBeDefined();
        expect(descendant.bar).toBeDefined();
        expect(descendant.hasOwnProperty('foo')).not.toBe(true);
    });
    
    it ('allows descendants to override their parent properties', function() {
        var anotherFlag = false,
            Descendant = Util.extend(Ancestor, {
                foo: function() {
                    anotherFlag = true;
                }
            }),
            descendant = new Descendant();
            
            descendant.foo();
            
            expect(anotherFlag).toBe(true);
            expect(fooFlag).toBe(false);
    });
});

describe('The generated constructor', function() {
    it('calls the create method', function() {
        var NewClass = Util.define({
                create: function(arg) {
                    this.arg = arg;
                }
            }),
            newClassInstance = new NewClass(10);
        
        expect(newClassInstance.arg).toBe(10);
    });
});

describe('The property annotation', function() {
    var TestClass = Util.define({
            properties: ['readWrite', 'anotherProp', 'customGetterSetter',
                {field: '_readOnly', getter: true},
                {field: '_writeOnly', setter: true},
                {field: '_named', getter: 'getThing', setter: 'setThing'},
            ],
            
            _readOnly: true,
            _customGetterSetter: true,
            
            getCustomGetterSetter: function() {
                return 10;
            },
            
            setCustomGetterSetter: function() {
                this._customGetterSetter = 20;
            }
        }),
        testInstance;
    
    beforeEach(function() {
        testInstance = new TestClass();
    });
    
    it('allows to autogenerate getters and setters', function() {
        expect(testInstance.getReadWrite()).toBeNull();
        testInstance.setReadWrite(true);
        expect(testInstance.getReadWrite()).toBe(true);
    });
    
    it('getters and setters can be enabled individually', function() {
        expect(testInstance.getReadOnly).toBeDefined();
        expect(testInstance.setReadOnly).not.toBeDefined();
        expect(testInstance.getWriteOnly).not.toBeDefined();
        expect(testInstance.setWriteOnly).toBeDefined();
        expect(testInstance.getReadOnly()).toBe(true);
        expect(testInstance._writeOnly).toBeNull();
        testInstance.setWriteOnly(true);
        expect(testInstance._writeOnly).toBe(true);
    });
    
    it('manually defined getters / setter have precedence over the autogenerated functions', function() {
        expect(testInstance.getCustomGetterSetter()).toBe(10);
        testInstance.setCustomGetterSetter(false);
        expect(testInstance._customGetterSetter).toBe(20);
    });
    
    it('getter / setter names can be customized', function() {
        expect(testInstance.getThing()).toBeNull();
        testInstance.setThing(true);
        expect(testInstance.getThing()).toBe(true);
    });
    
    it('autogenerated setters can be chained', function() {
        testInstance.setReadWrite(10).setAnotherProp(20);
        expect(testInstance.getReadWrite()).toBe(10);
        expect(testInstance.getAnotherProp()).toBe(20);
    });
});

describe('The mixins annotation', function() {
    it('copies all properties of the mixin class to the class prototype', function() {
        var Source = Util.define({
                foo: 1
            }),
            NewClass = Util.define({
                mixins: [Source]
            }),
            newClass = new NewClass();
        
        expect(newClass.foo).toBeDefined();
        expect(newClass.hasOwnProperty('foo')).toBe(false);
    });
    
    it('mixins can be either constructors, instances or plain objects', function() {
        var SourceClass = Util.define({
                foo: 1
            }),
            sourceInstance = new SourceClass(),
            plainSource = {
                foo: 1
            },
            NewClass1 = Util.define({
                mixins: [SourceClass]
            }),
            NewClass2 = Util.define({
                mixins: [sourceInstance]
            }),
            NewClass3 = Util.define({
                mixins: [plainSource]
            });
            
            expect((new NewClass1()).foo).toBeDefined();
            expect((new NewClass2()).foo).toBeDefined();
            expect((new NewClass3()).foo).toBeDefined();
    });
    
    it('does descend into the mixin\'s prototype and flattens the hierarchy', function() {
        var SourceBase = Util.define({
                foo: 1
            }),
            Source = Util.extend(SourceBase, {
                bar: 1
            }),
            NewClass = Util.define({
                mixins: [Source]
            });
        
        expect(NewClass.prototype.hasOwnProperty('foo')).toBe(true);
        expect(NewClass.prototype.hasOwnProperty('bar')).toBe(true);
    });
    
    it('does not override properties defined in the same class, but '
            + 'overrides properties defined on the prototype', function() {
        var base = {bar: 1},
            TargetClass1 = Util.define({
                mixins: [base],
                bar: 20
            }),
            TargetClass2 = Util.extend(TargetClass1, {
                mixins: [base]
            });
        
        expect((new TargetClass1()).bar).toBe(20);
        expect((new TargetClass2()).bar).toBe(1);
    });
});

describe('The base class Util.Base', function() {
    
    describe('provides the getConfig method which', function() {
        var NewClass = Util.extend(Util.Base, {
                properties: ['foo', 'bar'],
                
                setBarCalled: false,
                
                create: function(config) {
                    this.getConfig(config, ['foo', 'bar', 'baz']);
                },
                
                setBar: function(bar) {
                    this._bar = bar;
                    this.setBarCalled = true;
                }
            });
            
            it('is a convenience function for initializing properties from a config object', function() {
                var instance = new NewClass({foo: 1, bar: 2});
                
                expect(instance.getFoo()).toBe(1);
                expect(instance.getBar()).toBe(2);
            });
            
            it('does not enforce existence of the configured properties', function() {
                expect(function() {new NewClass({});}).not.toThrow();
            });
            
            it('uses setters where applicable...', function() {
                var instance = new NewClass({bar: 1});
                
                expect(instance.setBarCalled).toBe(true);
            });
            
            it('... and prefixes the property with an underscore _ otherwise', function() {
                var instance = new NewClass({baz: 1});
                
                expect(instance._baz).toBe(1);
            });
    });  
    
    it('provides stub create and destroy methods', function() {
        expect(_.isFunction(Util.Base.prototype.create)).toBe(true);
        expect(_.isFunction(Util.Base.prototype.destroy)).toBe(true);
    });
    
});